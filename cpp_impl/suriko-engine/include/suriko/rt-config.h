#pragma once
#include <exception> // std::terminate
#include <gsl/gsl_assert>

// the external user configuration generated by cmake
// defines SRK_DEBUG, SRK_SCALAR_TYPE etc.
#include "rt-config-autogen.h"

// SRK_ASSERT is similar to standard assert macros, but can be
#if defined(SRK_DEBUG)
#include <glog/logging.h>
// use Google glog CHECK macro
#define SRK_ASSERT(expr) CHECK(expr)
#else
namespace suriko {
struct NoopOut // allows putting messages after assert, like ASSERT(false) << "failed";
{
    template <typename T>
    NoopOut& operator <<([[maybe_unused]] T x) { return *this; }
};
}
// The macro:
// SRK_ASSERT(get_false()) << "leo";
// Expands into (with added square brackets to show operators precedence).
// (get_false()) ? (void)0 : [NoopOut() << "leo"];
// First get_false is executed, then <<.
// The result of expression [true ? (void)0 : Noop&] is Noop&.
#define SRK_ASSERT(expr) (expr) ? (void)0 : NoopOut()
#endif

namespace suriko {

/// Preferred way to turn on/off debug branches at runtime (compared to SRK_DEBUG preprocessor directive).
static constexpr bool kSurikoDebug =
#if defined(SRK_DEBUG)
    true;
#else
    false;
#endif

// typedef double Scalar;
typedef
#if defined(SRK_SCALAR_TYPE)
    SRK_SCALAR_TYPE
#else
    double
#endif
    Scalar;

/// Indicates that the point of function call is never reached. This allows to satisfy the compiler,
/// which otherwise emits a warning "not all control paths return a value".
//[[noreturn]] inline void AssertFalse() { std::terminate(); }
[[noreturn]] inline void AssertFalse() { Ensures(false); }
}