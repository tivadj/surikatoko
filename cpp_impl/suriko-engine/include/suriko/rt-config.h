#pragma once
#include <exception> // std::terminate
#include <gsl/gsl_assert>

// the external user configuration generated by cmake
// defines SRK_DEBUG, SRK_SCALAR_TYPE etc.
#include "rt-config-autogen.h"

// SRK_ASSERT is similar to standard assert macros, but can be
#if defined(SRK_DEBUG)
#include <glog/logging.h>
// use Google glog CHECK macro
#define SRK_ASSERT(expr) CHECK(expr)
#else
namespace suriko {
struct NoopOut // allows putting messages after assert, like ASSERT(false) << "failed";
{
    template <typename T>
    NoopOut& operator <<([[maybe_unused]] T x) { return *this; }
};
/// This is taken from glog/logging.h at line 1342
// This class is used to explicitly ignore values in the conditional
// logging macros.  This avoids compiler warnings like "value computed
// is not used" and "statement has no effect".
class LogMessageVoidify {
public:
    LogMessageVoidify() { }
    // This has to be an operator with a precedence lower than << but
    // higher than ?:
    //void operator&(std::ostream&) { }
    void operator&(const suriko::NoopOut&) { }
};
}
// The macro:
// SRK_ASSERT(get_false()) << "leo";
// Expands into (with added square brackets to show operators precedence).
// (get_false()) ? (void)0 : [LogMessageVoidify{} & [NoopOut{} << "leo"]];
// First get_false is executed, then <<, then &.
// The transformation of the expression is the following:
// [false ? (void)0 : [Voidify & [Noop& << "leo"]]
// [false ? (void)0 : [Voidify & Noop&]]
// [false ? (void)0 : void]=void.
#define SRK_ASSERT(expr) (expr) ? (void)0 : suriko::LogMessageVoidify{} & suriko::NoopOut{}

#endif

namespace suriko {

/// Preferred way to turn on/off debug branches at runtime (compared to SRK_DEBUG preprocessor directive).
static constexpr bool kSurikoDebug =
#if defined(SRK_DEBUG)
    true;
#else
    false;
#endif

// typedef double Scalar;
typedef
#if defined(SRK_SCALAR_TYPE)
    SRK_SCALAR_TYPE
#else
    double
#endif
    Scalar;

static constexpr bool kSurikoParallelEngine =
#if defined(SRK_PARALLEL_ENGINE)
true;
#else
false;
#endif


/// Indicates that the point of function call is never reached. This allows to satisfy the compiler,
/// which otherwise emits a warning "not all control paths return a value".
//[[noreturn]] inline void AssertFalse() { std::terminate(); }
[[noreturn]] inline void AssertFalse() { Ensures(false); }
}